#include "zero4/Zero4ScriptReader.h"
#include "zero4/Zero4MsgConsts.h"
#include "util/TBufStream.h"
#include "util/TParse.h"
#include "exception/TGenericException.h"
#include "exception/TException.h"
#include <cctype>
#include <algorithm>
#include <string>
#include <iostream>


// for testing: if set, unrecognized symbols will be ignored
#define ZERO4READER_IGNORE_BAD_INPUT 0


using namespace BlackT;

namespace Pce {


//const static int scriptBufferCapacity = 0x10000;
const static int literalSize = 5;

const static int code_end     = 0xFF;
const static int scene_code_br      = 0xFE;
const static int scene_code_end     = 0xFF;

const static double framesPerSecond = 60;

// in italic mode, characters with ID >= this are modified
const static int italicModeMinId = 0x01;
// characters with ID < this are modified
const static int italicModeMaxId = 0x50;
// amount added to italicizable characters in italic mode
const static int italicModeOffset = 0x52;

// when applying auto-off, delay this many additional seconds
// past the end of the sound before turning off the subtitles
// (sound files are usually clipped as close to the end of the
// content as possible, and we don't want to have the subtitles cut off
// too abruptly at the end)
//const static double autoOffOverhang = 0.320;
const static double autoOffOverhang = 0.200;
// don't allow an auto-off command to generate a time shorter than this
// (every subtitle needs to be on screen long enough to be readable,
// even if it means it's significantly longer than the corresponding audio)
const static double minOnTime = 1.000;
// the end times of point pairs generated by the points command
// is reduced by this amount (in frames) to account for the manner
// in which the karaoke gradient is generated:
// the end time represents the time at which the ride side of the
// gradient will reach the target point, whereas what we generally
// want is for the gradient to completely disappear at that point
const static int pointEndLeftFrameOffset = 0;

Zero4ScriptReader::ResultString::ResultString()
  : originalOffset(-1),
    originalSize(-1),
    initialized(false),
    autoStarted(false),
    isLiteral(false),
    isNotCompressible(false) { }

Zero4ScriptReader::ResultRegion::ResultRegion()
  : regionType(regionType_none),
    soundCount(0),
    choiceCount(0) { }

Zero4ScriptReader::Zero4ScriptReader(
                  BlackT::TStream& src__,
                  NameToRegionMap& dst__,
                  std::string localeId__)
  : src(src__),
    dst(dst__),
    thingy(BlackT::TThingyTable()),
    lineNum(0),
    breakTriggered(false),
    regionName("0"),
    metaRegionName(""),
    localeId(localeId__),
    tableBaseDir("table/"),
    sceneModeOn(false),
    stringIsActive(false),
    italicModeOn(false),
    lastWaitTime(0.0),
    timeScale(1.0)
/*    sceneModeOn(false)*/ {
//  loadThingy(thingy__);
//  spaceOfs.open((outprefix + "msg_space.txt").c_str());
//  indexOfs.open((outprefix + "msg_index.txt").c_str());
  resetScriptBuffer();
}

bool Zero4ScriptReader::operator()() {
  try {
    while (!src.eof()) {
      std::string line;
      src.getLine(line);
      ++lineNum;
      
  //    std::cerr << lineNum << std::endl;
      if (line.size() <= 0) continue;
      
      // discard lines containing only ASCII spaces and tabs
  //    bool onlySpace = true;
  //    for (int i = 0; i < line.size(); i++) {
  //      if ((line[i] != ' ')
  //          && (line[i] != '\t')) {
  //        onlySpace = false;
  //        break;
  //      }
  //    }
  //    if (onlySpace) continue;
      
      TBufStream ifs(line.size());
      ifs.write(line.c_str(), line.size());
      ifs.seek(0);
      
      // check for special stuff
      if (ifs.peek() == '#') {
        // directives
        ifs.get();
        processDirective(ifs);
        
        if (breakTriggered) {
          breakTriggered = false;
          return false;
        }
        
        continue;
      }
      
      while (!ifs.eof()) {
        // check for comments
        if ((ifs.remaining() >= 2)
            && (ifs.peek() == '/')) {
          ifs.get();
          if (ifs.peek() == '/') break;
          else ifs.unget();
        }
        
        outputNextSymbol(ifs);
      }
    }
    
    if (currentScriptBuffer.size() > 0) {
      flushActiveScript();
    }
    
    return true;
  }
  catch (TGenericException& e) {
    std::cerr << "Exception on script line " << std::dec << lineNum << ": " << std::endl;
    std::cerr << e.problem() << std::endl;
    throw e;
  }
  catch (TException& e) {
    std::cerr << "Exception on script line " << std::dec << lineNum << ": " << std::endl;
    std::cerr << e.what() << std::endl;
    throw e;
  }
  catch (std::exception& e) {
    std::cerr << "Exception on script line " << std::dec << lineNum << ": " << std::endl;
    std::cerr << e.what() << std::endl;
    throw e;
  }
}
  
void Zero4ScriptReader::loadThingy(const BlackT::TThingyTable& thingy__) {
  thingy = thingy__;
}
  
void Zero4ScriptReader::outputNextSymbol(TStream& ifs) {
//  if (currentScriptIsLiteral) {
//    currentScriptBuffer.put(ifs.get());
//    return;
//  }
  
  // if handling a sound in scene mode and auto-on is not disabled,
  // generate appropriate wait command
  if (sceneModeOn
      && (currentResult.hasProperty("startTime"))
      && (!currentResult.propertyIsTrue("noAutoStart"))
      && (!currentResult.autoStarted)
//      && (currentScriptBuffer.size() > 0)
      ) {
    double soundStartTime = TStringConversion::fromString<double>(
      currentResult.properties.at("startTime"));
    double autoOnTime = soundStartTime - lastWaitTime;
    
 /*   if (lastWaitTime < soundEndTime) {
      // duration between last wait and auto-off must exceed minimum
      double autoOffTime = soundEndTime + autoOffOverhang;
      if ((autoOffTime - lastWaitTime) < minOnTime) {
        autoOffTime = lastWaitTime + minOnTime;
      }
      
      outputWaitCommand(autoOffTime);
      outputOffCommand();
    }*/
    
    if (autoOnTime > 0) {
      outputWaitCommand(autoOnTime);
    }
    
    currentResult.autoStarted = true;
  }

  // flag that we have put content into a string so we know to terminate it later
  stringIsActive = true;

  // literal value
  if ((ifs.remaining() >= literalSize)
      && (ifs.peek() == literalOpenSymbol)) {
    int pos = ifs.tell();
    
    ifs.get();
    if (ifs.peek() == '$') {
      ifs.get();
      std::string valuestr = "0x";
//      valuestr += ifs.get();
//      valuestr += ifs.get();
      valuestr += ifs.get();
      valuestr += ifs.get();
      
      if (ifs.peek() == literalCloseSymbol) {
        ifs.get();
        int value = TStringConversion::stringToInt(valuestr);
        
//        currentScriptBuffer.writeu16be(value);
        currentScriptBuffer.writeu8(value);

        return;
      }
    }
    
    // not a literal value
    ifs.seek(pos);
  }
  
  // HACK: no matter what, a "_" in the input toggles italic mode
  // ...actually, after jumping through all those hoops to make sure
  // there was enough room in the font for an italic version,
  // even rearranging the order of the symbols to optimize for it,
  // i don't really like the way the italics look,
  // so i'm just dropping them.
  // what a shame.
/*  if (ifs.peek() == '_') {
    ifs.get();
    italicModeOn = !italicModeOn;
    return;
  }*/
  
  TThingyTable::MatchResult result;
  result = thingy.matchTableEntry(ifs);
  
  if (result.id != -1) {
//    std::cerr << std::dec << lineNum << " " << std::hex << result.id << " " << result.size << std::endl;
    
    // if italics on and character in italicizable range,
    // add offset to get index of italic version of character
    if (italicModeOn) {
      int code = result.id;
      if ((code >= italicModeMinId) && (code < italicModeMaxId)) {
        result.id += italicModeOffset;
      }
    }
    
    // HACK: values above 0x10000 are pseudo-codepoints for inline preprocessor
    // directives
/*    if (result.id >= 0x10000) {
      switch (result.id) {
      case Zero4MsgConsts::pseudoOp_startFont_bold:
        setActiveFont("bold");
        return;
        break;
      case Zero4MsgConsts::pseudoOp_endFont_bold:
        setActiveFont("std");
        return;
        break;
      case Zero4MsgConsts::pseudoOp_startFont_narrow:
        setActiveFont("narrow");
        return;
        break;
      case Zero4MsgConsts::pseudoOp_endFont_narrow:
        setActiveFont("std");
        return;
        break;
      case Zero4MsgConsts::pseudoOp_startFont_gil:
        setActiveFont("italic");
        return;
        break;
      case Zero4MsgConsts::pseudoOp_endFont_gil:
        setActiveFont("std");
        return;
        break;
      default:
        break;
      }
    }*/
    
    // if a font change op, switch fonts accordingly
    switch (result.id) {
    case Zero4MsgConsts::transOp_setFont_std:
      setActiveFont("std");
      break;
    case Zero4MsgConsts::transOp_setFont_monospace:
      setActiveFont("monospace");
      break;
    case Zero4MsgConsts::transOp_setFont_monospaceIt:
      setActiveFont("monospace_it");
      break;
    case Zero4MsgConsts::transOp_setFont_bold:
      setActiveFont("bold");
      break;
    case Zero4MsgConsts::transOp_setFont_italic:
      setActiveFont("italic");
      break;
    case Zero4MsgConsts::transOp_setFont_ascii:
      setActiveFont("asciistrict");
      break;
    default:
      break;
    }
    
/*    int symbolSize;
    if (result.id <= 0xFF) symbolSize = 1;
    else if (result.id <= 0xFFFF) symbolSize = 2;
    else if (result.id <= 0xFFFFFF) symbolSize = 3;
    else symbolSize = 4;*/
    
    // use autodetected byte width from table, which is based on number of
    // characters that appear on left side of equals symbol in table file
    int symbolSize = thingy.getEntryByteCount(result.id);
//    std::cerr << thingy.getEntry(result.id) << " " << std::hex << result.id << " " << std::dec << symbolSize << std::endl;
    
    currentScriptBuffer.writeInt(result.id, symbolSize,
      EndiannessTypes::big, SignednessTypes::nosign);
    
    return;
  }

  #if ZERO4READER_IGNORE_BAD_INPUT
    // ignore unrecognized characters
    // (and handle sjis sequences)
//    if (((ifs.readu8() & 0x80) != 0) && !ifs.eof()) ifs.get();
    ifs.get();
    return;
  #endif
  
  std::string remainder;
  ifs.getLine(remainder);
  
  // if we reached end of file, this is not an error: we're done
//  if (ifs.eof()) return;
  
  throw TGenericException(T_SRCANDLINE,
                          "Zero4ScriptReader::outputNextSymbol()",
                          "Line "
                            + TStringConversion::intToString(lineNum)
                            + ":\n  Couldn't match symbol at: '"
                            + remainder
                            + "'");
}
  
void Zero4ScriptReader::flushActiveScript() {
//  if (currentScriptBuffer.size() <= 0) return;
  // empty strings are valid, so check for valid ID instead
  if (!currentResult.initialized) return;
  
/*  // append terminator as needed
  if (sceneModeOn) {
    // scene strings are not zero-terminated
    currentScriptBuffer.put(scene_code_end);
  }
  else {
    currentScriptBuffer.put(code_end);
  } */
  
//  terminateCurrentStringIfActive();
  
  if (dst[regionName].propertyIsTrue("stringsAreSceneFormat")) {
    // HACK: empty scene strings don't get terminator,
    // so that their final size will be zero and the code that
    // processes them knows not to bother outputting files for them
    if (currentScriptBuffer.size() > 0) {
      // HACK
      int opcode = thingy.matchTableEntry("[end]").id;
      currentScriptBuffer.writeu8(opcode);
    }
  }
  
  // if handling a sound in scene mode and auto-off is not disabled,
  // generate appropriate wait and off commands
  // (if content exists)
  if (sceneModeOn
      && (currentResult.hasProperty("soundLen"))
      && (!currentResult.propertyIsTrue("noAutoOff"))
      && (currentScriptBuffer.size() > 0)) {
//    std::cerr << currentResult.properties.size() << std::endl;
    
    double soundEndTime = TStringConversion::fromString<double>(
      currentResult.properties.at("soundLen"));
    
    if (lastWaitTime < soundEndTime) {
      // duration between last wait and auto-off must exceed minimum
      double autoOffTime = soundEndTime + autoOffOverhang;
      if ((autoOffTime - lastWaitTime) < minOnTime) {
        autoOffTime = lastWaitTime + minOnTime;
      }
      
      outputWaitCommand(autoOffTime);
      outputOffCommand();
    }
  }
  
  // add stream terminator if in scene mode
  if (sceneModeOn) {
    outputTerminateCommand();
  }

  int outputSize = currentScriptBuffer.size();
  
  ResultString result = currentResult;
  currentScriptBuffer.seek(0);
  while (!currentScriptBuffer.eof()) {
    result.str += currentScriptBuffer.get();
  }
  
  dst[regionName].strings.push_back(result);
  
  // clear script buffer
  resetScriptBuffer();
}

void Zero4ScriptReader::resetScriptBuffer() {
  currentScriptBuffer = TBufStream();
/*  currentScriptSrcOffset = -1;
  currentScriptSrcSize = -1;
  currentScriptIsLiteral = false;*/
//  currentScriptIndices.clear();
  
  lastWaitTime = 0.0;
  timeScale = 1.0;
  
  currentResult = ResultString();
}

void Zero4ScriptReader::terminateCurrentStringIfActive() {
  if (stringIsActive) {
    outputTerminateCommand();
    stringIsActive = false;
  }
}

void Zero4ScriptReader::outputTerminateCommand() {
  int opcode = thingy.matchTableEntry("[null]").id;
  currentScriptBuffer.writeu8(opcode);
}

void Zero4ScriptReader::outputOffCommand() {
  terminateCurrentStringIfActive();
  
  int opcode = thingy.matchTableEntry("[off]").id;
  currentScriptBuffer.writeu8(opcode);
}

void Zero4ScriptReader::outputWaitCommand(double secTime) {
  terminateCurrentStringIfActive();
  
  // convert argument from seconds to frames
  int frameValue = secTime * framesPerSecond;
  
  // output wait command
  int opcode = thingy.matchTableEntry("[wait]").id;
  currentScriptBuffer.writeu8(opcode);
  currentScriptBuffer.writeu16be(frameValue * timeScale);
  
  lastWaitTime = secTime;
}

void Zero4ScriptReader::outputSlotCommand(int slotNum) {
  terminateCurrentStringIfActive();
  
  int opcode = thingy.matchTableEntry("[slot]").id;
  currentScriptBuffer.writeu8(opcode);
  currentScriptBuffer.writeu8(slotNum);
}

void Zero4ScriptReader::outputPalCommand(int palNum) {
  terminateCurrentStringIfActive();
  
  int opcode = thingy.matchTableEntry("[pal]").id;
  currentScriptBuffer.writeu8(opcode);
  currentScriptBuffer.writeu8(palNum);
}

void Zero4ScriptReader
    ::outputPointsCommand(double point1time, double point2time) {
  terminateCurrentStringIfActive();
  
  // fudge the numbers a bit:
  // we would like to pretend the span is a bit shorter
  // than actually specified, because the endpoint actually
  // indicates the time at which the gradient will *begin*
  // flowing out of the the segment rather than when
  // it will *end*.
  // the "correct" way to do this would be to compute the
  // width of the corresponding segment in pixels
  // and subtract the width of the gradient from that...
  // and wait, can't i just do that in the subtitle code itself?
  
  // convert argument from seconds to frames
  int frameValue1 = point1time * framesPerSecond;
  int frameValue2 = point2time * framesPerSecond;
  
  // apply frame offset for endpoint
  frameValue2 -= pointEndLeftFrameOffset;
  
  int opcode = thingy.matchTableEntry("[points]").id;
  currentScriptBuffer.writeu8(opcode);
  currentScriptBuffer.writeu16be(frameValue1 * timeScale);
  currentScriptBuffer.writeu16be(frameValue2 * timeScale);
}

void Zero4ScriptReader
    ::outputAlignModeCommand(int alignMode) {
  terminateCurrentStringIfActive();
  
  int opcode = thingy.matchTableEntry("[align]").id;
  currentScriptBuffer.writeu8(opcode);
  currentScriptBuffer.writeu8(alignMode);
}

void Zero4ScriptReader
    ::outputSyncCommand(int modeId, int targetValue, double newTime) {
  terminateCurrentStringIfActive();
  
  int frameTime = newTime * framesPerSecond;
  // update last seen time to new time
  lastWaitTime = newTime;
  
  int opcode = thingy.matchTableEntry("[sync]").id;
  currentScriptBuffer.writeu8(opcode);
  currentScriptBuffer.writeu8(modeId);
  currentScriptBuffer.writeu16be(targetValue);
  currentScriptBuffer.writeu16be(frameTime * timeScale);
}

void Zero4ScriptReader
    ::outputStartStreamCommand(int streamIndex, int scriptId) {
  terminateCurrentStringIfActive();
  
  int opcode = thingy.matchTableEntry("[startstream]").id;
  currentScriptBuffer.writeu8(opcode);
  currentScriptBuffer.writeu8(streamIndex);
  currentScriptBuffer.writeu8(scriptId);
}

void Zero4ScriptReader::processDirective(BlackT::TStream& ifs) {
  TParse::skipSpace(ifs);
  
  std::string name = TParse::matchName(ifs);
  TParse::matchChar(ifs, '(');
  
  for (int i = 0; i < name.size(); i++) {
    name[i] = toupper(name[i]);
  }
  
  if (name.compare("LOADTABLE") == 0) {
    processLoadTable(ifs);
  }
  else if (name.compare("STARTSTRING") == 0) {
/*    currentResult.id = TParse::matchString(ifs);
    TParse::matchChar(ifs, ',');
    currentScriptSrcOffset = TParse::matchInt(ifs);
    TParse::matchChar(ifs, ',');
    currentScriptSrcSize = TParse::matchInt(ifs);*/
    currentResult.id = TParse::matchString(ifs);
    currentResult.initialized = true;
//    processStartMsg(ifs);
  }
  else if (name.compare("SETORIGINALPOS") == 0) {
    currentResult.originalOffset = TParse::matchInt(ifs);
    TParse::matchChar(ifs, ',');
    currentResult.originalSize = TParse::matchInt(ifs);
  }
  else if (name.compare("ENDSTRING") == 0) {
    processEndMsg(ifs);
  }
  else if (name.compare("INCBIN") == 0) {
    processIncBin(ifs);
  }
  else if (name.compare("BREAK") == 0) {
    processBreak(ifs);
  }
  else if (name.compare("STARTREGION") == 0) {
    processStartRegion(ifs);
  }
  else if (name.compare("STARTMETAREGION") == 0) {
    processStartMetaRegion(ifs);
  }
  else if (name.compare("ENDREGION") == 0) {
    processEndRegion(ifs);
  }
  else if (name.compare("SETREGIONTYPE") == 0) {
    std::string name = TParse::matchString(ifs);
    if (name.compare("area") == 0) {
      dst[regionName].regionType = regionType_area;
    }
    else if (name.compare("adv") == 0) {
      dst[regionName].regionType = regionType_adv;
    }
    else {
      throw TGenericException(T_SRCANDLINE,
                              "Zero4ScriptReader::processDirective()",
                              "Line "
                                + TStringConversion::intToString(lineNum)
                                + ":\n  Unknown region type name: "
                                + name);
    }
  }
  else if ((name.compare("SETREGIONPROPERTY") == 0)) {
    std::string name = TParse::matchString(ifs);
    TParse::matchChar(ifs, ',');
    std::string value = TParse::matchString(ifs);
//    currentResult.properties[name] = value;
    dst[regionName].properties[name] = value;
  }
  else if ((name.compare("SETSTRINGPROPERTY") == 0)) {
    std::string name = TParse::matchString(ifs);
    TParse::matchChar(ifs, ',');
    std::string value = TParse::matchString(ifs);
    currentResult.properties[name] = value;
  }
  else if (name.compare("ADDPOINTERREF") == 0) {
    currentResult.pointerRefs.push_back(TParse::matchInt(ifs));
  }
  else if (name.compare("SETNOTCOMPRESSIBLE") == 0) {
    currentResult.isNotCompressible = (TParse::matchInt(ifs) != 0);
  }
  else if (name.compare("ADDFREESPACE") == 0) {
    int offset = TParse::matchInt(ifs);
    TParse::matchChar(ifs, ',');
    int size = TParse::matchInt(ifs);
    
    dst[regionName].freeSpace.free(offset, size);
  }
  else if (name.compare("ADDFONT") == 0) {
    std::string fontName = TParse::matchString(ifs);
    TParse::matchChar(ifs, ',');
    std::string outputTableName = TParse::matchString(ifs);
    
    // map font name to corresponding table
    fontNameToOutputTableName[fontName] = outputTableName;
    // read table file if it isn't already loaded
    if (outputTableNameToContent.find(outputTableName)
        == outputTableNameToContent.end()) {
      std::string filename = tableBaseDir + localeId + "/" + outputTableName;
      outputTableNameToContent[outputTableName].readUtf8(filename);
    }
  }
  else if (name.compare("SETFONT") == 0) {
    // switch to output table for this font
    std::string fontName = TParse::matchString(ifs);
//    std::string outputTableName = fontNameToOutputTableName.at(fontName);
//    thingy = outputTableNameToContent.at(outputTableName);
    setActiveFont(fontName);
  }
  else {
    throw TGenericException(T_SRCANDLINE,
                            "Zero4ScriptReader::processDirective()",
                            "Line "
                              + TStringConversion::intToString(lineNum)
                              + ":\n  Unknown directive: "
                              + name);
  }
  
  TParse::matchChar(ifs, ')');
}

void Zero4ScriptReader::processLoadTable(BlackT::TStream& ifs) {
  std::string tableName = TParse::matchString(ifs);
  TThingyTable table(tableName);
  loadThingy(table);
}

void Zero4ScriptReader::processStartMsg(BlackT::TStream& ifs) {
/*  currentScriptSrcOffset = TParse::matchInt(ifs);
  TParse::matchChar(ifs, ',');
  currentScriptSrcPointer = TParse::matchInt(ifs);
  TParse::matchChar(ifs, ',');
  currentScriptSrcSize = TParse::matchInt(ifs);
  TParse::matchChar(ifs, ',');
  currentScriptIsLiteral = (TParse::matchInt(ifs) != 0); */
}

void Zero4ScriptReader::processEndMsg(BlackT::TStream& ifs) {
  flushActiveScript();
}

void Zero4ScriptReader::processIncBin(BlackT::TStream& ifs) {
  std::string filename = TParse::matchString(ifs);
  TBufStream src(1);
  src.open(filename.c_str());
  currentScriptBuffer.writeFrom(src, src.size());
}

void Zero4ScriptReader::processBreak(BlackT::TStream& ifs) {
  breakTriggered = true;
}

void Zero4ScriptReader::processStartRegion(BlackT::TStream& ifs) {
  flushActiveScript();
  if (TParse::checkInt(ifs)) {
    regionName = TStringConversion::toString(TParse::matchInt(ifs));
  }
  else {
    regionName = TParse::matchString(ifs);
  }
  
  dst[regionName].metaRegion = metaRegionName;
}

void Zero4ScriptReader::processStartMetaRegion(BlackT::TStream& ifs) {
  flushActiveScript();
  if (TParse::checkInt(ifs)) {
    metaRegionName = TStringConversion::toString(TParse::matchInt(ifs));
  }
  else {
    metaRegionName = TParse::matchString(ifs);
  }
}

void Zero4ScriptReader::processEndRegion(BlackT::TStream& ifs) {
//  TParse::matchInt(ifs);
//  TParse::matchInt(ifs);
////  flushActiveScript();
//  breakTriggered = true;
}

/*void Zero4ScriptReader::processSetIndexList(BlackT::TStream& ifs) {
  currentScriptIndices.clear();
  while (TParse::checkInt(ifs)) {
    int next = TParse::matchInt(ifs);
    currentScriptIndices.push_back(next);
    if (!TParse::checkChar(ifs, ',')) break;
    TParse::matchChar(ifs, ',');
  }
} */

double Zero4ScriptReader::matchTime(BlackT::TStream& ifs) {
  double value = TParse::matchDouble(ifs);
  if (TParse::checkChar(ifs, ':')) {
    TParse::matchChar(ifs, ':');
    double seconds = TParse::matchDouble(ifs);
    value = (value * 60) + seconds;
  }
  return value;
}

void Zero4ScriptReader::setActiveFont(std::string fontName) {
  std::string outputTableName = fontNameToOutputTableName.at(fontName);
  thingy = outputTableNameToContent.at(outputTableName);
}


}
